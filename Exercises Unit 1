{- 1. Three positive integer values (x, y, z) are a Phytagoran triple if x²+y²=z², that is to say, 
if they correspond to lengths for sides of a triangle.

a) Define a function isTriple :: Integer -> Integer -> Integer -> Bool
to test whether three values are a Phytagorean triple. For instance:

Main> isTriple 3 4 5
True
Main>isTriple 3 4 6

 -}

isTriple :: Integer -> Integer -> Integer -> Bool
isTriple x y z  |x^2+y^2==z^2 = True
                |otherwise = False
	
{- b) For any x and y positive integers such that x>y, triple (x2-y2, 2xy, x2+y2) is Phytagorean. Accordingly, 
write  a  function  named  taking two numbers and returning a Phytagorean triple. For instance:

Main> triple 3 1
(8,6,10)
Main>isTriple 8 6 10
True -}

triple :: Integer -> Integer -> (Integer,Integer,Integer)
triple x y = (x^2-y^2, 2*x*y, x^2+y^2)

{- c) Read and understand the following property, that states that all triples generated by function are Phytagorean:

p_triples x y = x > 0 && y > 0 && x > y ==> isTriple l1 l2 h
    where
      (l1, l2, h) = triple x y -}
			
It checks that meanwhile x > 0 and y > 0, and we apply them the method triple, 
isTriple is True.

d) Check this property using QuickCheck (recall to import	at the beginning of your program and to copy the property into 
your file). You should observe a result similar to the following one:

Main> quickCheck p_triples
*** Gave up! Passed only 62 tests

Which means that, although only 62 test cases fulfilling the precondition where generated by
QuickCheck, all of them passed the test. -}



{- 2. Define a polymorphic function

swap :: (a,b) -> (b,a)

for swapping components in a two components tuple:

Main> swap (1,True)
(True,1)
Main> swap ('X','Y')
('Y','X') -}

swap :: (a,b) -> (b,a)
swap (x,y) = (y,x)



{- 3. This exercise is on sorting tuples.
a) Define an overloaded function for ordered types

sort2 :: (Ord a) => (a,a) -> (a,a)

taking a two components tuple (whose elements have the same type) and returning the corresponding ascending sorted tuple:

Main> sort2 (10,3)
(3,10)
Main> sort2 ('a','z')
('a','z') -}

sort2 :: Ord a => (a,a) -> (a,a)
sort2 (x,y) |x>y = (y,x)
            |otherwise = (x,y)

{- b) Copy the following properties for function	into your script:

p1_sort2 x y = sorted (sort2(x,y))
  where
    sorted (x,y) = x <= y

p2_sort2 x y = sameElements (x,y) (sort2(x,y))
  where
    sameElements (x,y) (x', y') = (x==x' && y==y') || (x==y' && y==x')

Understand each of these properties and test them using QuickCheck. -}

The first property checks whether the elements are sorted checking that the first
element is smaller than the second one. It's checked with quickCheck with the following
instruction: quickCheck (p1_sort2 :: Ord a => a -> a -> Bool)

The second property that once sorted, both elements remain the same, they've not
changed therefore the first is equal to the other first one and the same with the
second one or just the other way around, the first with the other second and
the second with the other first. It's checked with quickCheck with the following
instruction: quickCheck (p2_sort2 :: Ord a => a -> a -> Bool)

{- c) Define an overloaded function sort3 :: Ord a => (a,a,a) -> (a,a,a)
taking a tuple with three components of the same type and returning it sorted in ascending order:

Main> sort3 (10,3,7)
(3,7,10) -}

sort3 :: Ord a => (a,a,a) -> (a,a,a)
sort3 (x,y,z) |x>y = sort3(y,x,z)
              |y>z = sort3(x,z,y)
              |otherwise = (x,y,z)

{- d) Write similar properties to  the ones in  paragraph b)  but for	function, and test them using
QuickCheck. -}

p1_sort3 x y z = sorted (sort3(x,y,z))
  where
    sorted(x,y,z) = x <= y && y <= z
		
quickCheck (p1_sort3 :: Ord a => a -> a -> a -> Bool)

p2_sort3 x y z = sameElements (x,y,z) (sort3(x,y,z))
  where
    sameElements (x,y,z) (x',y',z') = (x==x' && y==y' && z==z') || (x==x' && y==z' && y') || (x==y' && y==x' && z==z') || (x==z' && y==y' && z==x') || (x==y' && y==z' && z==x')
https://avatars0.githubusercontent.com/u/23080252?s=96&v=4
quickCheck (p2_sort3 :: Bool -> Bool -> Bool -> Bool)

                



